import logging

proof = logging.FileHandler("output/proof.txt")
proof.setLevel(logging.INFO)
family = logging.FileHandler("output/F.py")
family.setLevel(logging.WARNING)
logging.basicConfig(handlers=[proof, family], format='%(message)s', encoding='utf-8', level=logging.INFO, force=True)

def attempts_as_string(extensions, indices):
    output = ""
    do_vertex_line = True
    do_edge_line = True
    for i in sorted(indices):
        attempt = extensions[i]
        if isinstance(attempt, list): #new vertex
            if do_vertex_line:
                output += "adding a new vertex whose neighbourhood is: "
                do_vertex_line = False
            N = [v for v in range(len(attempt)) if attempt[v] == 1]
            output += str(N) + " or "
        else: #new multiedge
            if do_edge_line:
                output += "adding a multiplicity for edge: "
                do_edge_line = False
            output += str(attempt) + " or "
    return output[:-4]

"""        
def multigraph_as_string(M):
    return "Testing multigraph with edges: " + str(M.edges(labels= False))
"""

def log_intro():
    #TODO clean logs
    log_proof("This is a full-proof of Lemma X generated by a computer.")
    log_family("# The list of all multigraphs from family F by their edges. The list is generated by a computer.")
    log_family("F = []")

def log_case(case, k, number): 
    log_proof("")
    print_and_log_proof("# Case", case, "-- we consider k =", k, "##################################################################")
    print_and_log_proof("There are precisely", number, "non-isomorphic graphs on", k, "vertices which contain a C_" + str(k))
    print_and_log_proof("and contain neither solved shorter cycle nor diamond as a subgraph nor induced Gamma_3 in line graph.")    

def log_subcase(subcase, M, text):
    log_proof("") #TODO to next line
    log_proof("#", subcase, text)
    log_proof("Testing multigraph with edges:", str(M.edges(labels=False)))
    
def log_problem(P):
    if len(P[1]) == 0:
        log_proof("The multigraph does not have 10 vertices of degree at least 3, vertices of smaller degree are", P[0], "a new vertex or muliedge should be added.")
    elif len(P[1]) == 1: #cut-vertex
        log_proof("Cut-vertex", P[1], "gives non-trivial components and the component", P[0], "should have an additional neighbour.")
    elif len(P[1]) == 2: #2-edge-cut
        log_proof("2-edge-cut", P[1], "gives non-trivial components and the component", P[0], "should have an additional neighbour or one of", P[1], "should be a multiedge.")
    elif len(P[1]) == 3: #triangle
        log_proof("Triangle", P[1], "contains vertex", P[0], "and", P[0], "should have a neighbour outside the triangle.")
    elif len(P[1]) == 5: #D1 -- its 5 vertices 
        log_proof("Subgraph D_1", P[1], "contains vertex", P[0], "and", P[0], "should have a neighbour outside D1.")
    elif len(P[1]) == 6: #K2_4 -- its 6 vertices
        if len(P[0]) == 2:
            log_proof("Subgraph D_2", P[1], "so some of", P[0], "should have an additional neighbour.")    
        elif len(P[0]) == 4:
            log_proof("subgraph K_{2,4}", P[1], "so some of", P[0], "should have an additional neighbour.")
        else:
            log_proof("multigraph from K^M_{2,4}", P[1], "so some of", P[0], "should have an additional neighbour.")
    elif len(P[1]) == 10: #SK2_4 -- its 10 vertices
        log_proof("multigraph from K^M_{4,P_4}", P[1], "so some of", P[0], "should have a greater degree sum.")
    
def log_proof(*arguments):
    logger = logging.getLogger()
    logger.info(assemble_string(*arguments))
    
def log_family(*arguments):
    logger = logging.getLogger()
    logger.warning(assemble_string(*arguments))
    
def assemble_string(*arguments):
    output = ""
    for a in arguments:
        output += str(a) + " "
    return output[:-1]
    
def print_and_log_proof(*arguments):
    print(*arguments)
    log_proof(*arguments)
    
def print_and_log_family(*arguments):
    print(*arguments)
    log_family(*arguments)